	•	High-level clarity (what the project does, why it’s useful).
	•	Technical depth (how you solved it, data structures, algorithms).
	•	Storytelling (make it engaging, not just code-walking).

Here’s how I’d restructure your script into a clean interview-ready answer:

⸻

🔹 Elevator Pitch (Start with this)

“My project is a mini search engine CLI tool. The idea is:
	•	You give it a query in natural language,
	•	It searches through a database of problems and retrieves the most relevant ones,
	•	And if available, it also links the corresponding solutions.”

⸻

🔹 Workflow Explanation (Layman + Technical)
	1.	Input Handling
	•	User enters a search query like "binary search tree".
	•	I break this into individual words using a stringstream.
	•	Words are stored in an array and mapped with their index in a map (problemStatement).
	2.	Searching in Problem File
	•	I have a file (Generic_Problem.txt) that contains all the problem statements.
	•	I load it into a map (getFileToMap) where each line has an index → problem text.
	•	For each query word, I search all lines using regex word-boundary matching (\bword\b) so that "tree" doesn’t match "street".
	•	The results are stored in a filter_search array, where each index corresponds to the word and contains the list of line numbers it matched.
Example:
	•	"binary" → lines [1, 3, 5]
	•	"search" → lines [2, 3]
	•	"tree" → lines [1, 3]
	3.	Combining Matches
	•	I count how many words from the query matched in each line → stored in a map lineMatchCounts.
	•	So if line 3 matched all three words, its match count = 3.
	•	This gives me a relevance score.
	4.	Fetching Solutions
	•	I also load a second file (Generic_Solution.txt) that has URLs mapped line-wise.
	•	If a line in problems matches, I fetch the corresponding solution URL.
	5.	Ranking Results
	•	I create SearchResult objects (problem text, URL, match count).
	•	Then I sort results in descending order of relevance score.
Example Output:
	•	Match score: 3/3 → “Search in binary tree” (with solution link).
	•	Match score: 2/3 → “Binary tree implementation” (with solution link).
	6.	No Matches Case
	•	If nothing matches, I append the user query to the problem file → system becomes self-learning by recording new queries.

⸻

🔹 Why This is Interesting
	•	It mimics how a real search engine pipeline works (tokenization → indexing → scoring → retrieval).
	•	Used maps, vectors, regex, and sorting → strong use of C++ STL.
	•	Implemented a self-updating database (new queries get stored).
	•	Can be extended into a full-fledged search system with inverted index or TF-IDF later.

⸻

👉 If the interviewer asks deeper:
	•	Talk about regex boundaries (\bword\b) to avoid partial matches.
	•	Mention time complexity (linear scan through file, can be improved with indexing).
	•	Discuss scalability improvements (like hashmaps, trie, or search libraries).
